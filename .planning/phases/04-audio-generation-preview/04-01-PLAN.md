---
phase: 04-audio-generation-preview
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/orders/[id]/status/route.ts
  - src/app/api/orders/[id]/variants/[variantId]/preview/route.ts
  - src/app/api/orders/[id]/variants/[variantId]/select/route.ts
autonomous: true

must_haves:
  truths:
    - "Authenticated user can poll generation status for their order and see per-variant progress"
    - "Authenticated user can fetch preview audio as a blob stream through the proxy endpoint"
    - "Authenticated user can mark a variant as selected"
    - "Unauthenticated requests receive 401 on all endpoints"
    - "Users cannot access other users' orders or variants"
  artifacts:
    - path: "src/app/api/orders/[id]/status/route.ts"
      provides: "GET endpoint returning order_status and per-variant generation_status"
      exports: ["GET"]
    - path: "src/app/api/orders/[id]/variants/[variantId]/preview/route.ts"
      provides: "GET endpoint returning audio blob with anti-download headers"
      exports: ["GET"]
    - path: "src/app/api/orders/[id]/variants/[variantId]/select/route.ts"
      provides: "POST endpoint to mark a variant as selected"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/orders/[id]/status/route.ts"
      to: "song_variants table"
      via: "Supabase query with join"
      pattern: "supabase.*from.*orders.*select.*song_variants"
    - from: "src/app/api/orders/[id]/variants/[variantId]/preview/route.ts"
      to: "Supabase Storage"
      via: "createSignedUrl then fetch blob"
      pattern: "storage.*createSignedUrl"
    - from: "src/app/api/orders/[id]/variants/[variantId]/select/route.ts"
      to: "song_variants table"
      via: "Supabase update"
      pattern: "supabase.*from.*song_variants.*update.*selected"
---

<objective>
Create the three backend API endpoints needed for the generation progress and preview experience: a status polling endpoint, a protected audio preview endpoint, and a variant selection endpoint.

Purpose: These endpoints provide the server-side infrastructure for Phase 4's client-side generation page. The status endpoint enables polling during generation. The preview endpoint serves audio as a blob to prevent direct URL exposure in devtools. The select endpoint records the user's final variant choice.

Output: Three new API route files under src/app/api/orders/[id]/ that handle auth verification, ownership checks, and correct response formats.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md
@src/lib/supabase.ts
@src/types/database.ts
@src/app/api/webhook/route.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create order status polling endpoint and variant selection endpoint</name>
  <files>
    src/app/api/orders/[id]/status/route.ts
    src/app/api/orders/[id]/variants/[variantId]/select/route.ts
  </files>
  <action>
Create GET handler at `src/app/api/orders/[id]/status/route.ts`:
- Import `createServerSupabaseClient` from `@/lib/supabase` and use the service_role client pattern (consistent with existing API routes like webhook/route.ts)
- Accept orderId from params
- Auth check: Call `supabase.auth.getUser()` -- BUT since we use service_role client (no user session), we need a different auth approach. Instead, use the anon client pattern with cookies for auth. Actually, looking at existing code: the service_role client bypasses RLS. For user-scoped queries, we need to verify auth differently.
- **Auth pattern:** Since existing API routes use `createServerSupabaseClient()` which is service_role (no user session), we must extract the user from the request. Use `@supabase/ssr` createServerClient with cookies from the request to get the authenticated user, then query with the service_role client filtering by user_id. If `@supabase/ssr` is not set up for API routes, use a simpler approach: read the `sb-*` access token from cookies, decode the JWT to get user_id (using the supabase anon client's `auth.getUser(token)` method). OR simplest: create a new anon-key Supabase client in the route handler using the request cookies to get the session.
- **Simplest correct approach:** Create a Supabase client using the anon key + user's auth cookie to verify identity, then use service_role client to query (bypasses RLS for flexibility). Check: `const { data: { user } } = await anonClient.auth.getUser()`. If no user, return 401.
- Query: `supabase.from('orders').select('id, status, song_variants(id, variant_number, generation_status, storage_path, completed_at)').eq('id', params.id).eq('user_id', user.id).single()`
- Return JSON: `{ order_id, order_status: order.status, variants: order.song_variants }` with 200
- If order not found or not owned by user, return 404

Create POST handler at `src/app/api/orders/[id]/variants/[variantId]/select/route.ts`:
- Same auth pattern as status endpoint
- Verify user owns the variant: query song_variants where id=variantId AND order_id=params.id AND user_id=user.id
- If not found, return 404
- Update: `supabase.from('song_variants').update({ selected: true }).eq('id', params.variantId)`
- Also unselect other variants for same order: `supabase.from('song_variants').update({ selected: false }).eq('order_id', params.id).neq('id', params.variantId)`
- Return `{ success: true, selected_variant_id: params.variantId }` with 200

**Important:** For auth in API route handlers, use this pattern since the existing codebase uses `createServerSupabaseClient()` with service_role key:
```typescript
import { createClient } from '@supabase/supabase-js'
import { cookies } from 'next/headers'

// Get user from auth cookie
const cookieStore = await cookies()
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
  { global: { headers: { Cookie: cookieStore.toString() } } }
)
const { data: { user } } = await supabase.auth.getUser()
// Then use createServerSupabaseClient() for data queries (service_role)
```

If this cookie approach doesn't work cleanly, fall back to passing the Authorization header's bearer token to `supabase.auth.getUser(token)` instead.
  </action>
  <verify>
TypeScript compilation: `npx tsc --noEmit` passes (or at minimum, the new files have no type errors).
Verify files exist: `ls src/app/api/orders/\[id\]/status/route.ts src/app/api/orders/\[id\]/variants/\[variantId\]/select/route.ts`
  </verify>
  <done>
Status endpoint returns order status with per-variant generation_status array. Select endpoint toggles selected flag on chosen variant and unselects others. Both endpoints require authentication and verify ownership.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create protected audio preview endpoint</name>
  <files>
    src/app/api/orders/[id]/variants/[variantId]/preview/route.ts
  </files>
  <action>
Create GET handler at `src/app/api/orders/[id]/variants/[variantId]/preview/route.ts`:
- Same auth pattern as Task 1 (cookie-based user verification + service_role data client)
- Verify user owns the variant: query `song_variants` where id=variantId AND order_id=params.id AND user_id=user.id, select `storage_path, generation_status`
- If variant not found or not owned, return 404
- If generation_status !== 'complete', return 400 with `{ error: 'Variant not ready' }`
- Generate signed URL with 10-minute expiry: `supabase.storage.from('songs').createSignedUrl(variant.storage_path, 600)`
- If signed URL generation fails, return 500
- Fetch the audio from the signed URL: `const audioResponse = await fetch(signedUrlData.signedUrl)`
- If fetch fails, return 500
- Convert to ArrayBuffer: `const audioBuffer = await audioResponse.arrayBuffer()`
- Return as NextResponse with the audio buffer and these headers:
  - `Content-Type: audio/mpeg`
  - `Content-Disposition: inline` (force inline playback, not download)
  - `Cache-Control: private, no-cache, no-store, must-revalidate`
  - `X-Content-Type-Options: nosniff`

This endpoint acts as a proxy: client fetches from /api/orders/[id]/variants/[variantId]/preview, receives a raw audio blob. The signed storage URL is never exposed to the client. Client creates a blob URL with URL.createObjectURL() for the audio element.

**Key decision from research (03-03 decision):** storage_path stores Supabase Storage path, not signed URL. Signed URLs generated on-demand. This endpoint is the on-demand generator + proxy.
  </action>
  <verify>
TypeScript compilation: `npx tsc --noEmit` passes for the new file.
Verify file exists: `ls src/app/api/orders/\[id\]/variants/\[variantId\]/preview/route.ts`
  </verify>
  <done>
Preview endpoint serves audio as inline blob with anti-download headers. Signed storage URL is never exposed to client. Requires authentication and ownership verification. Returns 400 if variant not yet complete.
  </done>
</task>

</tasks>

<verification>
1. All three route files exist under src/app/api/orders/[id]/
2. TypeScript compilation passes (npx tsc --noEmit or check for errors in new files)
3. Status endpoint returns order_status and variants array
4. Preview endpoint returns audio/mpeg content with inline Content-Disposition
5. Select endpoint toggles selected flag on variant
6. All endpoints return 401 for unauthenticated requests
7. All endpoints return 404 for orders/variants not owned by the authenticated user
</verification>

<success_criteria>
Three API endpoints created and TypeScript-clean: /api/orders/[id]/status (GET), /api/orders/[id]/variants/[variantId]/preview (GET), /api/orders/[id]/variants/[variantId]/select (POST). All endpoints authenticate users and verify ownership before serving data.
</success_criteria>

<output>
After completion, create `.planning/phases/04-audio-generation-preview/04-01-SUMMARY.md`
</output>
