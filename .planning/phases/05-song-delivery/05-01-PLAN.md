---
phase: 05-song-delivery
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/songs/[id]/route.ts
  - src/app/api/songs/[id]/download/route.ts
  - src/app/api/songs/[id]/stream/route.ts
autonomous: true

must_haves:
  truths:
    - "Song metadata API returns variant details joined with order and customization data for the authenticated owner"
    - "Download endpoint returns audio with Content-Disposition attachment header triggering browser download"
    - "Stream endpoint returns audio proxied through API (signed URL never exposed to client) with 2-hour signed URL expiry"
    - "Only the selected variant can be downloaded or streamed"
    - "Non-owners receive 404 (not 403) to prevent enumeration"
  artifacts:
    - path: "src/app/api/songs/[id]/route.ts"
      provides: "Song metadata endpoint"
      exports: ["GET"]
    - path: "src/app/api/songs/[id]/download/route.ts"
      provides: "MP3 download endpoint"
      exports: ["GET"]
    - path: "src/app/api/songs/[id]/stream/route.ts"
      provides: "Audio streaming proxy endpoint"
      exports: ["GET"]
  key_links:
    - from: "src/app/api/songs/[id]/route.ts"
      to: "song_variants + orders + customizations"
      via: "Supabase join query"
      pattern: "supabase\\.from\\('song_variants'\\)"
    - from: "src/app/api/songs/[id]/download/route.ts"
      to: "Supabase Storage"
      via: "createSignedUrl + fetch proxy"
      pattern: "Content-Disposition.*attachment"
---

<objective>
Create the backend API endpoints for song delivery: metadata retrieval, audio streaming, and MP3 download.

Purpose: Phase 5 needs API routes that serve the selected song variant's metadata (occasion, recipient, date) and audio (both streaming and downloadable). These endpoints follow the established auth + proxy pattern from Phase 4 preview but with key differences: they use song_variant ID as the primary identifier (not order+variant pair), enforce selected=true, use 2-hour signed URL expiry, and the download endpoint sets Content-Disposition to attachment.

Output: Three API route handlers -- GET /api/songs/[id] for metadata, GET /api/songs/[id]/stream for proxied audio playback, GET /api/songs/[id]/download for MP3 file download.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 4 established the auth + proxy pattern for audio endpoints
@src/app/api/orders/[id]/variants/[variantId]/preview/route.ts
@src/types/database.ts
@src/lib/supabase.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create song metadata API endpoint</name>
  <files>src/app/api/songs/[id]/route.ts</files>
  <action>
Create GET /api/songs/[id] endpoint where [id] is a song_variant UUID. This endpoint returns metadata for the selected song variant joined with its order and customization data.

Implementation:
1. Use the established auth pattern: `createServerSupabaseClient()`, then `supabase.auth.getUser()`, return 401 if no user.
2. Validate UUID format of params.id using regex `/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i`. Return 400 if invalid.
3. Query `song_variants` table with a join to `orders` and `customizations`:
   ```
   supabase.from('song_variants')
     .select('id, variant_number, duration_ms, selected, created_at, completed_at, share_token, orders(id, occasion_date, created_at, customization_id, customizations(recipient_name, occasion, your_name, genre, mood))')
     .eq('id', params.id)
     .eq('selected', true)
     .eq('user_id', user.id)
     .single()
   ```
4. If no data or error, return 404 `{ error: 'Song not found' }` (not 403, to prevent enumeration).
5. Return 200 with the joined data shaped as:
   ```json
   {
     "id": "variant-uuid",
     "variantNumber": 1,
     "durationMs": 90000,
     "createdAt": "2026-02-08T...",
     "shareToken": "uuid",
     "recipientName": "Sarah",
     "occasion": "valentines",
     "senderName": "James",
     "genre": "pop",
     "mood": ["romantic"],
     "occasionDate": "2026-02-14",
     "orderCreatedAt": "2026-02-08T..."
   }
   ```
6. Map the nested Supabase response to the flat shape above for cleaner client consumption. Use camelCase keys.
7. Wrap entire handler in try-catch, log errors with `console.error('Error fetching song metadata:', error)`, return 500.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify file exists at src/app/api/songs/[id]/route.ts.</verify>
  <done>GET /api/songs/[id] returns song metadata with recipient_name, occasion, date created for the authenticated owner's selected variant. Returns 401 for unauthenticated, 400 for invalid UUID, 404 for non-existent/non-owned/non-selected variants.</done>
</task>

<task type="auto">
  <name>Task 2: Create stream and download API endpoints</name>
  <files>src/app/api/songs/[id]/stream/route.ts, src/app/api/songs/[id]/download/route.ts</files>
  <action>
Create two endpoints that both proxy audio from Supabase Storage but differ in headers:

**Stream endpoint (GET /api/songs/[id]/stream):**
1. Same auth pattern as Task 1 (getUser, 401 if no user).
2. Query song_variants for the variant by id, with `selected=true` and `user_id=user.id`. Return 404 if not found.
3. Check `generation_status === 'complete'`. Return 400 `{ error: 'Song not ready' }` if not complete.
4. Generate signed URL with **7200 second** (2 hour) expiry: `supabase.storage.from('songs').createSignedUrl(variant.storage_path, 7200)`.
5. Fetch the audio blob from signed URL.
6. Return audio with streaming headers:
   - `Content-Type: audio/mpeg`
   - `Content-Disposition: inline`
   - `Cache-Control: private, max-age=3600` (allow browser caching for 1 hour since user owns this)
   - `Accept-Ranges: bytes` (hint for progressive loading)

**Download endpoint (GET /api/songs/[id]/download):**
1. Same auth + ownership check as stream.
2. Same signed URL generation (2 hour expiry).
3. Fetch audio blob from signed URL.
4. Build filename from customization data. Query orders joined with customizations to get recipient_name:
   ```
   supabase.from('song_variants')
     .select('storage_path, generation_status, order_id, orders(customizations(recipient_name))')
     .eq('id', params.id)
     .eq('selected', true)
     .eq('user_id', user.id)
     .single()
   ```
5. Sanitize recipient_name for filename (replace non-alphanumeric with hyphens, lowercase): e.g., "Sarah's Song" becomes "sarahs-song".
6. Return audio with download headers:
   - `Content-Type: audio/mpeg`
   - `Content-Disposition: attachment; filename="songswipe-{sanitized-name}.mp3"`
   - `Content-Length: {buffer.byteLength}` (required for download progress)
   - `Cache-Control: private, no-cache`

Both endpoints must:
- Validate UUID format (400 if invalid).
- Only serve selected=true variants (enforced in query).
- Return 404 for non-owned variants (not 403).
- Wrap in try-catch with console.error logging and 500 response.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify both files exist at their respective paths.</verify>
  <done>Stream endpoint returns proxied audio with inline disposition and 1-hour cache. Download endpoint returns proxied audio with attachment disposition and sanitized filename. Both enforce selected=true and owner authentication. Signed URLs use 2-hour expiry to handle pause/resume scenarios.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. Three new route files exist:
   - src/app/api/songs/[id]/route.ts
   - src/app/api/songs/[id]/stream/route.ts
   - src/app/api/songs/[id]/download/route.ts
3. All three endpoints verify authentication and ownership
4. Download endpoint has Content-Disposition: attachment header
5. Stream endpoint has Content-Disposition: inline header
6. Both audio endpoints use 2-hour signed URL expiry (7200 seconds)
7. All endpoints enforce selected=true in their queries
</verification>

<success_criteria>
- Song metadata endpoint returns joined data from song_variants + orders + customizations
- Stream endpoint proxies audio without exposing signed URL to client
- Download endpoint triggers browser download with meaningful filename
- All endpoints authenticated and scoped to owner
- TypeScript compilation succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-song-delivery/05-01-SUMMARY.md`
</output>
