---
phase: 01-foundation-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase-schema-v2.sql
  - src/types/database.ts
autonomous: true

must_haves:
  truths:
    - "song_variants table exists with per-variant generation_status ENUM (pending/generating/complete/failed)"
    - "failed_jobs table exists as dead-letter queue for exhausted retries"
    - "orders table has occasion_date column for retention tracking"
    - "share_token column on song_variants is UUID type with UNIQUE constraint"
    - "RLS policies allow authenticated users to read own song_variants and anon users to read via share_token"
    - "RLS policies prevent cross-user data access on song_variants and failed_jobs"
    - "TypeScript types in database.ts match the new schema exactly"
  artifacts:
    - path: "supabase-schema-v2.sql"
      provides: "Complete migration SQL for song_variants, failed_jobs, orders.occasion_date, ENUM, indexes, RLS"
      contains: "CREATE TYPE generation_status"
    - path: "src/types/database.ts"
      provides: "TypeScript interfaces for all tables including new song_variants and failed_jobs"
      contains: "song_variants"
  key_links:
    - from: "src/types/database.ts"
      to: "supabase-schema-v2.sql"
      via: "TypeScript types mirror SQL schema"
      pattern: "generation_status.*pending.*generating.*complete.*failed"
---

<objective>
Create the database foundation for multi-variant song generation with per-variant status tracking, share tokens, dead-letter queue, and RLS policies with dual-access (authenticated owner + public anon via share_token).

Purpose: All subsequent Inngest job queue work (Plan 02) writes to these tables. Without the schema, types, and RLS policies in place, the generation function has nowhere to store variants or track failures.

Output: A migration SQL file ready to run in Supabase SQL Editor, and updated TypeScript types matching the new schema.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md

@supabase-schema.sql
@supabase-rls-fix.sql
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migration SQL for song_variants, failed_jobs, and orders.occasion_date</name>
  <files>supabase-schema-v2.sql</files>
  <action>
Create `supabase-schema-v2.sql` as the Phase 1 migration file. This file should be idempotent where possible (IF NOT EXISTS) and designed to run in Supabase SQL Editor on top of the existing schema.

Include in this order:

1. **Create ENUM type** for generation status:
   ```sql
   CREATE TYPE generation_status AS ENUM ('pending', 'generating', 'complete', 'failed');
   ```

2. **Create `song_variants` table**:
   - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - `order_id UUID NOT NULL REFERENCES orders(id) ON DELETE CASCADE`
   - `user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE`
   - `variant_number INTEGER NOT NULL CHECK (variant_number BETWEEN 1 AND 5)` -- allows up to 5 for +1 upsell
   - `storage_path TEXT NOT NULL` -- Supabase Storage path, not a signed URL
   - `duration_ms INTEGER` -- nullable until generation completes
   - `generation_status generation_status NOT NULL DEFAULT 'pending'`
   - `share_token UUID UNIQUE NOT NULL DEFAULT gen_random_uuid()` -- public sharing
   - `selected BOOLEAN DEFAULT false` -- user's favorite
   - `created_at TIMESTAMPTZ DEFAULT NOW()`
   - `completed_at TIMESTAMPTZ` -- when generation finished
   - UNIQUE constraint on `(order_id, variant_number)` to prevent duplicate variants

3. **Create `failed_jobs` table** (dead-letter queue):
   - `id UUID PRIMARY KEY DEFAULT gen_random_uuid()`
   - `job_type TEXT NOT NULL` -- e.g. 'song_generation'
   - `event_data JSONB NOT NULL` -- full Inngest event payload for debugging
   - `error_message TEXT NOT NULL`
   - `error_stack TEXT` -- optional full stack trace
   - `retry_count INTEGER NOT NULL`
   - `failed_at TIMESTAMPTZ DEFAULT NOW()`
   - `resolved_at TIMESTAMPTZ` -- manually set when issue addressed
   - `notes TEXT` -- manual resolution notes

4. **Alter orders table**: Add `occasion_date DATE` column (nullable, for Phase 9 retention):
   ```sql
   ALTER TABLE orders ADD COLUMN IF NOT EXISTS occasion_date DATE;
   ```

5. **Indexes**:
   - `idx_song_variants_order_id` on song_variants(order_id)
   - `idx_song_variants_user_id` on song_variants(user_id)
   - `idx_song_variants_share_token` on song_variants(share_token)
   - `idx_song_variants_status` on song_variants(generation_status)
   - `idx_failed_jobs_type` on failed_jobs(job_type)
   - `idx_failed_jobs_failed_at` on failed_jobs(failed_at)

6. **Enable RLS** on both new tables:
   ```sql
   ALTER TABLE song_variants ENABLE ROW LEVEL SECURITY;
   ALTER TABLE failed_jobs ENABLE ROW LEVEL SECURITY;
   ```

7. **RLS Policies for song_variants** (dual-access pattern):
   - "Users can view own song variants" -- FOR SELECT TO authenticated USING (auth.uid() = user_id)
   - "Users can update own song variants" -- FOR UPDATE TO authenticated USING (auth.uid() = user_id) -- needed for selecting favorite
   - "Public can view songs via share token" -- FOR SELECT TO anon USING (share_token IS NOT NULL) -- app layer validates specific token
   - "Service role can manage song variants" -- FOR ALL TO service_role USING (true) -- Inngest job queue uses service role key

   IMPORTANT: The service role policy must target the `service_role` role, NOT `authenticated`. The Inngest function uses the service role key which bypasses RLS by default in Supabase, but add the policy explicitly for clarity and future-proofing.

8. **RLS Policies for failed_jobs**:
   - "Service role can manage failed jobs" -- FOR ALL TO service_role USING (true) -- only system/admin access
   - No authenticated or anon policies -- regular users should never see failed_jobs

9. **Table comments**:
   - COMMENT ON song_variants: 'AI-generated song variants with per-variant status tracking and public share tokens'
   - COMMENT ON failed_jobs: 'Dead-letter queue for failed generation jobs after retry exhaustion'

Do NOT modify the existing `songs` table or its policies -- it will be deprecated later but must remain functional during transition. The `song_variants` table is the new canonical location for generated audio.

Add a header comment block explaining this is the Phase 1 migration and referencing the existing supabase-schema.sql as the base.
  </action>
  <verify>
Review the SQL file for:
- Valid PostgreSQL syntax (no Supabase-specific errors)
- ENUM values match exactly: 'pending', 'generating', 'complete', 'failed'
- Foreign key references point to existing tables (orders, users)
- RLS policies use correct role names (authenticated, anon, service_role)
- All indexes reference correct columns
- share_token has both UNIQUE constraint and index
- occasion_date ALTER uses IF NOT EXISTS
  </verify>
  <done>
supabase-schema-v2.sql exists with song_variants table (generation_status ENUM, share_token UUID UNIQUE, variant_number 1-5), failed_jobs table (JSONB event_data), orders.occasion_date column, all indexes, and RLS policies for dual-access (authenticated owner + anon share + service_role system).
  </done>
</task>

<task type="auto">
  <name>Task 2: Update TypeScript database types to match new schema</name>
  <files>src/types/database.ts</files>
  <action>
Update `src/types/database.ts` to add type definitions for the new tables and modified columns. Keep the existing table types exactly as they are (users, customizations, orders, songs) and ADD the following:

1. **Add `GenerationStatus` type alias** at the top of the file (after the Json type):
   ```typescript
   export type GenerationStatus = 'pending' | 'generating' | 'complete' | 'failed';
   ```

2. **Add `song_variants` table to Database interface** under Tables:
   - Row type: all fields as per SQL schema
     - `id: string` (UUID)
     - `order_id: string`
     - `user_id: string`
     - `variant_number: number`
     - `storage_path: string`
     - `duration_ms: number | null`
     - `generation_status: GenerationStatus`
     - `share_token: string`
     - `selected: boolean`
     - `created_at: string`
     - `completed_at: string | null`
   - Insert type: id, duration_ms, generation_status, share_token, selected, created_at, completed_at all optional
   - Update type: all fields optional

3. **Add `failed_jobs` table to Database interface** under Tables:
   - Row type:
     - `id: string`
     - `job_type: string`
     - `event_data: Json`
     - `error_message: string`
     - `error_stack: string | null`
     - `retry_count: number`
     - `failed_at: string`
     - `resolved_at: string | null`
     - `notes: string | null`
   - Insert type: id, error_stack, failed_at, resolved_at, notes optional
   - Update type: all fields optional

4. **Update `orders` Row type** to include `occasion_date: string | null` field. Also update Insert to include `occasion_date?: string | null` and Update to include `occasion_date?: string | null`.

Follow the exact same pattern as existing table type definitions. Use the same indentation (2 spaces) and formatting style.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation succeeds with the updated types. Check that GenerationStatus type is exported and accessible.
  </verify>
  <done>
database.ts contains song_variants and failed_jobs table types with Row/Insert/Update variants, GenerationStatus type alias exported, orders type includes occasion_date field, and `npx tsc --noEmit` passes.
  </done>
</task>

</tasks>

<verification>
1. supabase-schema-v2.sql exists and contains CREATE TYPE generation_status, CREATE TABLE song_variants, CREATE TABLE failed_jobs, ALTER TABLE orders ADD COLUMN occasion_date
2. src/types/database.ts exports GenerationStatus type and includes song_variants, failed_jobs in Database interface
3. TypeScript compiles without errors: `npx tsc --noEmit`
4. SQL file references only tables that exist in supabase-schema.sql (orders, users)
5. RLS policies cover: authenticated SELECT/UPDATE on song_variants, anon SELECT on song_variants, service_role ALL on both tables
</verification>

<success_criteria>
- Migration SQL is complete, syntactically valid, and ready to run in Supabase SQL Editor
- TypeScript types exactly mirror the SQL schema with proper nullable types
- RLS policies implement the dual-access pattern: owner access + public share access + system/service role access
- The existing schema is not modified (additive changes only, except the occasion_date ALTER)
- `npx tsc --noEmit` passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md`
</output>
