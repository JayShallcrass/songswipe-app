---
phase: 06-upsells-monetization
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/actions/create-bundle-checkout.ts
  - src/lib/bundles/redemption.ts
  - src/actions/checkout.ts
  - src/components/upsells/BundleOfferCard.tsx
  - src/app/song/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "After selecting their favorite song and viewing the delivery page, user sees a bundle offer with 3 tier options (3-pack, 5-pack, 10-pack)"
    - "User can select a bundle tier and proceed to Stripe Checkout for the bundle purchase"
    - "Bundle purchases create credit records in the database with correct quantity"
    - "Bundle credit redemption uses optimistic locking to prevent race conditions"
    - "Base checkout flow checks for available bundle credits before redirecting to Stripe, auto-applying a credit if available (PAY-06 redemption)"
    - "Bundle offer can be dismissed and does not block access to the song"
    - "Server Action validates bundle tier and pricing server-side before creating checkout"
  artifacts:
    - path: "src/actions/create-bundle-checkout.ts"
      provides: "Server Action for authenticated bundle purchase checkout"
      exports: ["createBundleCheckout"]
    - path: "src/lib/bundles/redemption.ts"
      provides: "Bundle credit redemption with optimistic locking and balance queries"
      exports: ["redeemBundleCredit", "getUserBundleBalance"]
    - path: "src/actions/checkout.ts"
      provides: "Updated base checkout with bundle credit check before Stripe redirect"
      contains: "getUserBundleBalance"
    - path: "src/components/upsells/BundleOfferCard.tsx"
      provides: "3-tier bundle offer card with selection, pricing, and checkout CTA"
      contains: "BundleOfferCard"
    - path: "src/app/song/[id]/page.tsx"
      provides: "Song delivery page with bundle offer below song player"
      contains: "BundleOfferCard"
  key_links:
    - from: "src/app/song/[id]/page.tsx"
      to: "src/components/upsells/BundleOfferCard.tsx"
      via: "rendered below song player and details"
      pattern: "BundleOfferCard"
    - from: "src/components/upsells/BundleOfferCard.tsx"
      to: "src/actions/create-bundle-checkout.ts"
      via: "handlePurchase calls Server Action"
      pattern: "createBundleCheckout"
    - from: "src/actions/create-bundle-checkout.ts"
      to: "src/lib/stripe.ts"
      via: "creates checkout session with bundle order type"
      pattern: "createCheckoutSession.*bundle"
    - from: "src/lib/bundles/redemption.ts"
      to: "supabase bundles table"
      via: "optimistic lock UPDATE with eq('quantity_remaining', currentValue)"
      pattern: "eq.*quantity_remaining"
    - from: "src/actions/checkout.ts"
      to: "src/lib/bundles/redemption.ts"
      via: "checks bundle balance before Stripe redirect, redeems credit if available"
      pattern: "getUserBundleBalance|redeemBundleCredit"
---

<objective>
Implement the post-completion bundle offer and credit redemption system: a bundle offer card on the song delivery page with 3 tiers, plus the backend credit tracking and redemption logic.

Purpose: PAY-05 and PAY-06 requirements. Captures lifetime value after the user experiences satisfaction (heard their song, selected favorite). Bundle credits allow frictionless future song creation.

Output: Server Action for bundle checkout, bundle credit redemption module, bundle offer UI component, updated song delivery page.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-upsells-monetization/06-RESEARCH.md
@.planning/phases/06-upsells-monetization/06-01-SUMMARY.md
@src/app/song/[id]/page.tsx
@src/lib/bundles/pricing.ts
@src/lib/bundles/types.ts
@src/actions/checkout.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create bundle checkout Server Action and credit redemption module</name>
  <files>
    src/actions/create-bundle-checkout.ts
    src/lib/bundles/redemption.ts
    src/actions/checkout.ts
  </files>
  <action>
    1. Create `src/actions/create-bundle-checkout.ts`:
       - 'use server' directive
       - Import createCheckoutSession from @/lib/stripe, createServerSupabaseClient from @/lib/supabase, validateBundlePrice and getBundleTier from @/lib/bundles/pricing
       - Export async function createBundleCheckout({ bundleTierId }: { bundleTierId: string }): Promise<{ url: string }>
       - Get authenticated user via supabase.auth.getUser(), throw if not authenticated
       - Look up bundle tier via getBundleTier(bundleTierId), throw if not found
       - Call createCheckoutSession with: customizationId: 'bundle-purchase' (bundles are not tied to a specific customization), userId, email, amount: tier.price, orderType: 'bundle', successUrl: /dashboard?bundle=success, cancelUrl: /song/{current-song}?bundle=canceled (or just /dashboard?bundle=canceled since we don't know song context), metadata: { bundleTier: tier.id, quantity: String(tier.quantity) }
       - Return { url: session.url }
       - Do NOT accept amount from client (look up from server-side tier definition)

    2. Create `src/lib/bundles/redemption.ts`:
       - Import createServerSupabaseClient from @/lib/supabase
       - Import BundleBalance from @/lib/bundles/types

       - Export async function redeemBundleCredit(userId: string): Promise<{ redeemed: boolean, bundleId?: string, remainingCredits?: number, error?: string }>
         - Use service_role Supabase client
         - Find oldest bundle with remaining credits: query bundles table WHERE user_id = userId AND quantity_remaining > 0, ORDER BY purchased_at ASC, LIMIT 1
         - If no bundle found, return { redeemed: false, error: 'No available bundle credits' }
         - Decrement credit atomically using optimistic locking: UPDATE bundles SET quantity_remaining = bundle.quantity_remaining - 1 WHERE id = bundle.id AND quantity_remaining = bundle.quantity_remaining
         - If update returns no rows (race condition), return { redeemed: false, error: 'Credit redemption failed (concurrent access)' }
         - On success, return { redeemed: true, bundleId: bundle.id, remainingCredits: bundle.quantity_remaining - 1 }

       - Export async function getUserBundleBalance(userId: string): Promise<BundleBalance>
         - Query bundles WHERE user_id = userId AND quantity_remaining > 0, ORDER BY purchased_at ASC
         - Return totalRemaining (sum of quantity_remaining) and array of bundle details
         - On error, return { totalRemaining: 0, bundles: [] }

    3. Update `src/actions/checkout.ts` (existing base checkout Server Action) to integrate bundle credit redemption:
       - Import getUserBundleBalance and redeemBundleCredit from @/lib/bundles/redemption
       - Before creating a Stripe checkout session for base orders, check if the user has available bundle credits: call getUserBundleBalance(userId)
       - If totalRemaining > 0: call redeemBundleCredit(userId). If redemption succeeds, skip Stripe checkout entirely -- instead create the order record directly (status: 'paid', payment_method: 'bundle_credit', amount: 0), trigger Inngest generation with variantCount: 3, and redirect to /generate/{orderId}. This fulfills PAY-06: "Bundle purchases are tracked and available for the user to redeem on future song creations."
       - If redeemBundleCredit fails (race condition), fall through to normal Stripe checkout
       - If totalRemaining === 0: proceed with normal Stripe checkout (existing behavior)
       - This means users with bundle credits get a free, instant checkout for their next song
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm TypeScript compiles.
    Verify Server Action does NOT accept amount parameter (looks up from tier definition).
    Verify redemption uses optimistic locking pattern (.eq('quantity_remaining', currentValue) in UPDATE).
    Verify getUserBundleBalance sums remaining credits across all bundles.
    Verify checkout.ts imports getUserBundleBalance and redeemBundleCredit.
    Verify checkout.ts checks bundle balance before Stripe redirect and bypasses payment when credits available.
  </verify>
  <done>
    Bundle checkout Server Action creates Stripe session with validated pricing. Credit redemption module uses optimistic locking to prevent race conditions. Balance query aggregates across all user bundles. Base checkout flow checks for bundle credits and auto-redeems, bypassing Stripe when credits are available (PAY-06 complete).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create bundle offer card and integrate into song delivery page</name>
  <files>
    src/components/upsells/BundleOfferCard.tsx
    src/app/song/[id]/page.tsx
  </files>
  <action>
    1. Create `src/components/upsells/BundleOfferCard.tsx`:
       - 'use client' directive
       - Import useState from react, createBundleCheckout from @/actions/create-bundle-checkout, BUNDLE_TIERS from @/lib/bundles/pricing, BundleTier from @/lib/bundles/types
       - Local state: selectedTier (default to BUNDLE_TIERS[1] which is 5-pack "popular"), isLoading, isDismissed
       - handlePurchase: set loading, call createBundleCheckout({ bundleTierId: selectedTier.id }), redirect with window.location.href. On error: console.error, alert.
       - If isDismissed, return null (component hides itself)
       - Render: purple-to-pink gradient background card (matching app theme), dismiss X button (top right), headline "Loved Your Song? Create More & Save", subheadline about stocking up credits
       - 3-column tier grid: each tier button shows quantity, "Songs" label, total price, per-song price, savings %. Selected tier has purple border + white bg + shadow. "Popular" badge on 5-pack tier (position absolute, -top-2, centered)
       - "What You Get" section: list with green checkmarks -- "{quantity} complete song generations (3 variants each)", "Credits never expire", "Use for any occasion or recipient", "Save £X.XX per song vs single purchase" (calculated from BASE_PRICE - selectedTier.perSongPrice)
       - CTA button: purple-to-pink gradient, full width, "Get {quantity} Songs for £{price}"
       - Social proof text: "Join customers who have purchased bundles for gifting throughout the year"
       - Format all prices as GBP: £{(price / 100).toFixed(2)}

    2. Modify `src/app/song/[id]/page.tsx`:
       - Import BundleOfferCard from @/components/upsells/BundleOfferCard
       - Render BundleOfferCard below the existing SongPlayer and SongDetails components
       - Add spacing between song content and bundle offer (e.g., mt-12 or a divider)
       - Bundle offer should be visible on load but not blocking the song content (user can scroll past or dismiss)
       - The bundle offer is non-intrusive: song player and download remain fully accessible above it
  </action>
  <verify>
    Run `npx tsc --noEmit` to confirm TypeScript compiles.
    Verify BundleOfferCard renders 3 tier options from BUNDLE_TIERS constant.
    Verify 5-pack tier is marked as "Popular" with badge.
    Verify dismiss button hides the component.
    Verify song page renders BundleOfferCard below song content.
  </verify>
  <done>
    Bundle offer card displays 3 tiers with selection, pricing, and checkout CTA. Song delivery page includes bundle offer below player (non-blocking). Dismissing hides the offer for the session. All pricing comes from server-side constants.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. Bundle Server Action uses tier lookup (not client-provided amount)
3. Credit redemption uses optimistic locking (.eq on quantity_remaining)
4. Bundle offer card shows 3 tiers with correct pricing from BUNDLE_TIERS
5. 5-pack marked as "Popular" with visual badge
6. Dismiss button hides bundle offer without blocking song access
7. Song delivery page renders bundle offer below player content
8. getUserBundleBalance aggregates across all active bundles
9. Base checkout (src/actions/checkout.ts) checks bundle balance and redeems credit before Stripe redirect
</verification>

<success_criteria>
- Song delivery page shows bundle offer below player with 3 tier options
- Default selection is 5-pack ("Popular") tier
- Accepting creates Stripe Checkout session and redirects
- Dismissing hides the offer for the session
- Bundle purchase webhook creates credit record with correct quantity (handled by Plan 01 webhook update)
- Credit redemption module uses optimistic locking for race condition prevention
- Balance query returns total remaining credits across all bundles
- Base checkout auto-redeems bundle credits when available, bypassing Stripe for free checkout (PAY-06)
</success_criteria>

<output>
After completion, create `.planning/phases/06-upsells-monetization/06-03-SUMMARY.md`
</output>
