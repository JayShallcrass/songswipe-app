---
phase: 05-song-delivery
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - package.json
  - src/lib/hooks/useSongData.ts
  - src/components/song/SongPlayer.tsx
  - src/components/song/SongDetails.tsx
  - src/app/song/[id]/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can stream their selected song in-browser with play/pause, seekbar, and volume controls"
    - "User can download their selected song as an MP3 file by clicking a download button"
    - "Song page at /song/[id] displays audio player, download button, and song details"
    - "Song page shows the occasion type, recipient name, and date created"
  artifacts:
    - path: "src/lib/hooks/useSongData.ts"
      provides: "React Query hook for song metadata and audio streaming"
      exports: ["useSongData"]
    - path: "src/components/song/SongPlayer.tsx"
      provides: "Audio player component with react-h5-audio-player"
    - path: "src/components/song/SongDetails.tsx"
      provides: "Song metadata display component"
    - path: "src/app/song/[id]/page.tsx"
      provides: "Dedicated song page"
  key_links:
    - from: "src/lib/hooks/useSongData.ts"
      to: "/api/songs/[id]"
      via: "React Query fetch"
      pattern: "fetch.*api/songs"
    - from: "src/components/song/SongPlayer.tsx"
      to: "/api/songs/[id]/stream"
      via: "audio src blob URL"
      pattern: "api/songs.*stream"
    - from: "src/app/song/[id]/page.tsx"
      to: "src/components/song/SongPlayer.tsx"
      via: "component composition"
      pattern: "SongPlayer"
---

<objective>
Build the song delivery frontend: install audio player library, create React Query hook, build SongPlayer and SongDetails components, and assemble the dedicated /song/[id] page.

Purpose: Users who have selected their favorite variant from the generation page need a dedicated song page where they can stream and download their personalized song. This page is the culmination of the creation flow and will also serve as the destination for share links in Phase 7.

Output: Dedicated song page at /song/[id] with professional audio player, download button, and song metadata display (occasion, recipient, date).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-song-delivery/05-01-SUMMARY.md

# Existing hooks for pattern reference
@src/lib/hooks/useAudioPreview.ts
@src/lib/hooks/useGenerationStatus.ts
@src/lib/providers.tsx
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-h5-audio-player and create useSongData hook</name>
  <files>package.json, src/lib/hooks/useSongData.ts</files>
  <action>
**Install audio player library:**
```bash
npm install react-h5-audio-player
```

**Create useSongData hook** at `src/lib/hooks/useSongData.ts`:

This hook fetches song metadata from the API created in Plan 01 and manages the audio blob URL for streaming.

1. Define TypeScript interface `SongData` matching the API response shape:
   ```typescript
   interface SongData {
     id: string
     variantNumber: number
     durationMs: number | null
     createdAt: string
     shareToken: string
     recipientName: string
     occasion: string
     senderName: string
     genre: string
     mood: string[]
     occasionDate: string | null
     orderCreatedAt: string
   }
   ```

2. Export `useSongData(songId: string)` hook that returns `{ song, audioUrl, isLoading, error, isDownloading, downloadSong }`.

3. Use `useQuery` from React Query for metadata fetch:
   - queryKey: `['song', songId]`
   - queryFn: `fetch('/api/songs/${songId}')` then parse JSON, throw on non-ok response
   - staleTime: `5 * 60 * 1000` (5 minutes -- metadata doesn't change)
   - enabled: `!!songId`
   - refetchOnWindowFocus: false

4. Use `useState` + `useEffect` for audio blob URL management (same pattern as useAudioPreview):
   - When song data is available, fetch `/api/songs/${songId}/stream`
   - Convert response to blob, create object URL via `URL.createObjectURL(blob)`
   - Store in state as `audioUrl`
   - Cleanup: revoke object URL on songId change or unmount
   - Track loading state separately (`audioLoading`)

5. Add `downloadSong` async function:
   - Set `isDownloading` state to true
   - Open `/api/songs/${songId}/download` in a new hidden anchor tag:
     ```typescript
     const link = document.createElement('a')
     link.href = `/api/songs/${songId}/download`
     link.download = ''  // Let server Content-Disposition control filename
     document.body.appendChild(link)
     link.click()
     document.body.removeChild(link)
     ```
   - Set `isDownloading` to false after a brief delay (500ms) since we can't track actual download completion
   - Wrap in try-catch

6. Return object: `{ song: data, audioUrl, isLoading: isQueryLoading || audioLoading, error, isDownloading, downloadSong }`

Mark the file with `'use client'` at the top since it uses React hooks.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify react-h5-audio-player appears in package.json dependencies.</verify>
  <done>react-h5-audio-player installed. useSongData hook fetches metadata via React Query, manages audio blob URL with proper cleanup, and provides downloadSong function using anchor tag pattern.</done>
</task>

<task type="auto">
  <name>Task 2: Create SongPlayer, SongDetails components and /song/[id] page</name>
  <files>src/components/song/SongPlayer.tsx, src/components/song/SongDetails.tsx, src/app/song/[id]/page.tsx</files>
  <action>
**Create SongPlayer component** at `src/components/song/SongPlayer.tsx`:

1. `'use client'` directive.
2. Import `AudioPlayer` from `react-h5-audio-player` and `'react-h5-audio-player/lib/styles.css'`.
3. Props: `{ audioUrl: string | null, isLoading: boolean }`.
4. When `isLoading` or `!audioUrl`, show a loading skeleton: centered div with `animate-pulse` background, rounded corners, matching player dimensions.
5. Render `<AudioPlayer>` with:
   - `src={audioUrl}`
   - `showJumpControls={false}` (no skip forward/back -- single song)
   - `customAdditionalControls={[]}` (remove loop, etc.)
   - `customVolumeControls={['VOLUME']}` (keep volume only)
   - `layout="stacked-reverse"` (controls below progress bar)
   - `className` with custom styling to match app theme (purple-to-pink gradient accents)
6. Add a `<style jsx global>` block or import a CSS file to override react-h5-audio-player default colors:
   - `.rhap_progress-filled` and `.rhap_progress-indicator`: use gradient from purple (`#8B5CF6`) to pink (`#EC4899`)
   - `.rhap_button-clear`: white color for dark background contexts
   - `.rhap_time`: white/gray text color
   - Keep it minimal -- only color overrides, not layout changes

**Create SongDetails component** at `src/components/song/SongDetails.tsx`:

1. `'use client'` directive.
2. Props: `{ recipientName: string, occasion: string, senderName: string, genre: string, mood: string[], createdAt: string, occasionDate: string | null }`.
3. Create a helper `formatLabel(value: string): string` that converts kebab-case to Title Case (e.g., "just-because" to "Just Because"). Reuse the pattern from SwipeCard formatting.
4. Render a card-style layout with:
   - Heading: "Song for {recipientName}" in large text (text-2xl font-bold)
   - Details grid (2 columns on md+, 1 on mobile) with labeled items:
     - "Occasion": formatLabel(occasion)
     - "From": senderName
     - "Genre": formatLabel(genre)
     - "Mood": mood.map(formatLabel).join(', ')
     - "Created": format createdAt as readable date using `new Date(createdAt).toLocaleDateString('en-GB', { day: 'numeric', month: 'long', year: 'numeric' })`
     - "Occasion Date": format occasionDate same way (only show if not null)
   - Each detail item: label in text-sm text-gray-400 uppercase, value in text-lg text-white
   - Use bg-white/5 backdrop-blur rounded-2xl p-6 card styling (matching app's dark glass-morphism pattern)

**Create /song/[id] page** at `src/app/song/[id]/page.tsx`:

1. This is a CLIENT component (`'use client'`) because it needs the useSongData hook for audio playback. The page itself handles loading/error states.
2. Import `useSongData` from `@/lib/hooks/useSongData`, `SongPlayer` from `@/components/song/SongPlayer`, `SongDetails` from `@/components/song/SongDetails`.
3. Extract `id` from `useParams()` (next/navigation).
4. Call `useSongData(id as string)`.
5. **Loading state**: Full-page centered spinner with purple gradient background (matching app theme). Show "Loading your song..." text with animate-pulse.
6. **Error state**: Full-page error message with "Song not found" heading, "This song may not exist or you may not have access." subtext, and a "Go Home" link to `/`.
7. **Success state**: Full-page layout with:
   - Dark gradient background (from-gray-900 via-purple-900/20 to-gray-900) matching app theme
   - Centered content container (max-w-2xl mx-auto px-4 py-12)
   - Top: SongSwipe logo or "SongSwipe" text link back to home
   - Song title area: "A Song for {recipientName}" in large gradient text (bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent)
   - SongPlayer component
   - Download button: Full-width button below player, gradient background (purple to pink), "Download MP3" text with download icon. On click calls `downloadSong()`. Shows "Downloading..." when `isDownloading` is true. Disabled during download.
   - SongDetails component with all metadata
   - Bottom spacing for mobile scroll comfort
8. Use Framer Motion `motion.div` for fade-in animation on content load (initial={{ opacity: 0, y: 20 }}, animate={{ opacity: 1, y: 0 }}).
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify all three files exist at their paths. Run `npm run build` to confirm no build errors.</verify>
  <done>Song page at /song/[id] renders audio player with play/pause/seek/volume controls, download button that triggers MP3 download, and song details showing occasion, recipient name, sender, genre, mood, and date created. Loading and error states handled gracefully with app-consistent styling.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `npm run build` succeeds
3. react-h5-audio-player is in package.json dependencies
4. Song page exists at src/app/song/[id]/page.tsx
5. SongPlayer component renders react-h5-audio-player with custom styling
6. SongDetails component displays occasion, recipient name, date created
7. Download button triggers browser download via /api/songs/[id]/download
8. Audio streams via blob URL from /api/songs/[id]/stream (signed URL not exposed)
9. Blob URL cleanup on unmount prevents memory leaks
</verification>

<success_criteria>
- /song/[id] page renders with audio player, download button, and song metadata
- Audio player has play/pause, seekbar, and volume controls
- Download button triggers MP3 file download with meaningful filename
- Song details show occasion type, recipient name, and date created
- Loading and error states handle gracefully
- No TypeScript errors, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/05-song-delivery/05-02-SUMMARY.md`
</output>
