---
phase: 08-user-dashboard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/app/api/dashboard/songs/route.ts
  - src/app/api/dashboard/orders/route.ts
  - src/app/api/dashboard/occasions/route.ts
  - src/lib/hooks/useSongHistory.ts
  - src/lib/hooks/useOrderHistory.ts
  - src/lib/hooks/useOccasions.ts
  - src/lib/hooks/useDownloadSong.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Dashboard API returns paginated song history with recipient names, occasions, and dates"
    - "Dashboard API returns order history with amounts, dates, and order types"
    - "Dashboard API returns occasion dates with upcoming reminders"
    - "React Query hooks fetch from dashboard API endpoints with pagination support"
    - "Download mutation triggers browser download via existing /api/songs/[id]/download endpoint"
  artifacts:
    - path: "src/app/api/dashboard/songs/route.ts"
      provides: "Paginated song history endpoint"
      exports: ["GET"]
    - path: "src/app/api/dashboard/orders/route.ts"
      provides: "Order/purchase history endpoint"
      exports: ["GET"]
    - path: "src/app/api/dashboard/occasions/route.ts"
      provides: "Occasion dates with upcoming reminders"
      exports: ["GET"]
    - path: "src/lib/hooks/useSongHistory.ts"
      provides: "React Query hook for paginated song history"
      exports: ["useSongHistory"]
    - path: "src/lib/hooks/useOrderHistory.ts"
      provides: "React Query hook for order history"
      exports: ["useOrderHistory"]
    - path: "src/lib/hooks/useOccasions.ts"
      provides: "React Query hook for occasion dates"
      exports: ["useOccasions"]
    - path: "src/lib/hooks/useDownloadSong.ts"
      provides: "React Query mutation for triggering download"
      exports: ["useDownloadSong"]
  key_links:
    - from: "src/lib/hooks/useSongHistory.ts"
      to: "/api/dashboard/songs"
      via: "fetch in queryFn"
      pattern: "fetch.*api/dashboard/songs"
    - from: "src/lib/hooks/useOrderHistory.ts"
      to: "/api/dashboard/orders"
      via: "fetch in queryFn"
      pattern: "fetch.*api/dashboard/orders"
    - from: "src/lib/hooks/useOccasions.ts"
      to: "/api/dashboard/occasions"
      via: "fetch in queryFn"
      pattern: "fetch.*api/dashboard/occasions"
    - from: "src/lib/hooks/useDownloadSong.ts"
      to: "/api/songs/[id]/download"
      via: "fetch in mutationFn"
      pattern: "fetch.*api/songs.*download"
---

<objective>
Create dashboard API endpoints and React Query hooks for song history, order history, occasion tracking, and song download.

Purpose: Backend data layer that the dashboard UI (Plan 02) will consume. Establishes paginated, authenticated endpoints for all dashboard sections and client-side hooks for data fetching/mutations.

Output: 3 API routes under /api/dashboard/, 4 React Query hooks, date-fns installed
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-user-dashboard/08-RESEARCH.md
@.planning/phases/05-song-delivery/05-01-SUMMARY.md
@.planning/phases/04-audio-generation-preview/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install date-fns and create dashboard API endpoints</name>
  <files>
    package.json
    src/app/api/dashboard/songs/route.ts
    src/app/api/dashboard/orders/route.ts
    src/app/api/dashboard/occasions/route.ts
  </files>
  <action>
    Install date-fns: `npm install date-fns`

    Create three authenticated API endpoints following the established auth pattern (createServerSupabaseClient().auth.getUser(), return 401 if no user).

    **GET /api/dashboard/songs** (paginated song history):
    - Accept query params: `page` (default 1), `pageSize` (default 10)
    - Query `song_variants` table where `user_id = user.id` AND `selected = true` AND `generation_status = 'complete'`
    - Select: id, variant_number, created_at, storage_path, and join orders -> customizations (recipient_name, occasion, genre, mood, sender_name)
    - Use `{ count: 'estimated' }` for total count
    - Order by created_at DESC
    - Use `.range(from, to)` for pagination where from = (page-1)*pageSize, to = from+pageSize-1
    - Flatten nested Supabase response (unwrap orders array -> customizations array)
    - Return JSON: `{ songs: [...], page, pageSize, total: count, pageCount: Math.ceil(count/pageSize) }`

    **GET /api/dashboard/orders** (order/purchase history):
    - Accept query params: `page` (default 1), `pageSize` (default 10)
    - Query `orders` table where `user_id = user.id`
    - Select: id, status, amount, order_type, created_at, stripe_session_id, and join customizations (recipient_name, occasion)
    - Use `{ count: 'estimated' }` for total count
    - Order by created_at DESC
    - Use `.range(from, to)` for pagination
    - Flatten nested customizations (unwrap array to single object)
    - Return JSON: `{ orders: [...], page, pageSize, total: count, pageCount }`

    **GET /api/dashboard/occasions** (occasion date tracking):
    - No pagination needed (typically small dataset)
    - Query `orders` table where `user_id = user.id` AND `occasion_date IS NOT NULL`
    - Select: id, occasion_date, created_at, and join customizations (recipient_name, occasion)
    - Order by occasion_date ASC
    - Flatten customizations
    - Return JSON: `{ occasions: [...] }`

    All endpoints use the established import pattern:
    ```typescript
    import { createServerSupabaseClient } from '@/lib/supabase'
    import { NextResponse } from 'next/server'
    ```

    For nested Supabase response handling, follow the pattern from 05-01:
    ```typescript
    const order = Array.isArray(item.orders) ? item.orders[0] : item.orders
    const customization = Array.isArray(order?.customizations) ? order.customizations[0] : order?.customizations
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no TypeScript errors.
    Confirm all 3 route files exist at correct paths.
    Confirm date-fns is in package.json dependencies.
  </verify>
  <done>
    Three authenticated API endpoints serve paginated song history, order history, and occasion dates. All filter by user_id, flatten nested Supabase responses, and follow established auth patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create React Query hooks for dashboard data fetching and download</name>
  <files>
    src/lib/hooks/useSongHistory.ts
    src/lib/hooks/useOrderHistory.ts
    src/lib/hooks/useOccasions.ts
    src/lib/hooks/useDownloadSong.ts
  </files>
  <action>
    Create four React Query hooks following the established pattern from useGenerationStatus/useSongData (see 04-02-SUMMARY.md).

    **useSongHistory(page: number = 1)**:
    - queryKey: ['songs', 'history', page]
    - queryFn: fetch `/api/dashboard/songs?page=${page}`, throw on !res.ok
    - Return typed response: `{ songs, page, pageSize, total, pageCount }`
    - staleTime: 60000 (1 minute -- data doesn't change frequently)
    - refetchOnWindowFocus: false

    **useOrderHistory(page: number = 1)**:
    - queryKey: ['orders', 'history', page]
    - queryFn: fetch `/api/dashboard/orders?page=${page}`, throw on !res.ok
    - Return typed response: `{ orders, page, pageSize, total, pageCount }`
    - staleTime: 60000
    - refetchOnWindowFocus: false

    **useOccasions()**:
    - queryKey: ['occasions']
    - queryFn: fetch `/api/dashboard/occasions`, throw on !res.ok
    - Use `select` option to transform data: filter to upcoming occasions (occasion_date > now AND < 90 days from now), calculate daysUntil, format date with date-fns `format(date, 'MMM d, yyyy')`, sort by daysUntil ASC
    - Import `format`, `isAfter`, `isBefore`, `addDays` from 'date-fns'
    - staleTime: 300000 (5 minutes -- occasion dates rarely change)

    **useDownloadSong()**:
    - useMutation (not useQuery)
    - mutationFn: accepts songId (string), fetches `/api/songs/${songId}/download`
    - On success: create blob URL from response, create anchor element with download attribute, programmatic click, clean up with URL.revokeObjectURL and remove anchor from DOM
    - Extract filename from Content-Disposition header (fallback: 'songswipe-song.mp3')
    - Return mutation object for isPending state in UI

    All hooks should define TypeScript interfaces for their response shapes inline (not in separate type files). Follow the pattern:
    ```typescript
    interface SongHistoryResponse {
      songs: SongHistoryItem[]
      page: number
      pageSize: number
      total: number
      pageCount: number
    }
    ```

    Each hook file starts with no directive (they import from @tanstack/react-query which handles client/server boundary).
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify no TypeScript errors.
    Confirm all 4 hook files exist at correct paths.
    Verify each hook imports from '@tanstack/react-query'.
    Verify useOccasions imports from 'date-fns'.
    Verify useDownloadSong uses useMutation (not useQuery).
  </verify>
  <done>
    Four React Query hooks provide typed data fetching for song history (paginated), order history (paginated), occasions (with date calculations), and song download (mutation with blob cleanup). All hooks follow established patterns from Phase 4/5.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `date-fns` appears in package.json dependencies
3. All 3 API routes exist under src/app/api/dashboard/
4. All 4 hooks exist under src/lib/hooks/
5. API routes use createServerSupabaseClient auth pattern
6. Song history endpoint paginates with .range() and returns total count
7. Order history endpoint includes order_type in response
8. Occasions endpoint filters for non-null occasion_date
9. useDownloadSong uses useMutation with blob URL cleanup
</verification>

<success_criteria>
- Dashboard API endpoints serve authenticated, paginated data for songs, orders, and occasions
- React Query hooks provide typed client-side data fetching with appropriate stale times
- Download mutation triggers browser download with proper cleanup
- All code passes TypeScript strict mode checking
</success_criteria>

<output>
After completion, create `.planning/phases/08-user-dashboard/08-01-SUMMARY.md`
</output>
