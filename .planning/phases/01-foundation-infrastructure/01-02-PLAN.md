---
phase: 01-foundation-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - package.json
  - src/lib/inngest/client.ts
  - src/lib/inngest/functions/generate-song.ts
  - src/app/api/inngest/route.ts
  - src/app/api/webhook/route.ts
  - .env.example
autonomous: true
user_setup:
  - service: inngest
    why: "Async job queue for song generation with retry logic"
    env_vars:
      - name: INNGEST_EVENT_KEY
        source: "Inngest Dashboard -> Manage -> Event Keys (or use Inngest Dev Server locally with no key needed)"
      - name: INNGEST_SIGNING_KEY
        source: "Inngest Dashboard -> Manage -> Signing Key (required for production webhook verification)"
    dashboard_config:
      - task: "Create Inngest account and connect to Vercel project"
        location: "https://www.inngest.com -> Sign up -> Connect Vercel integration (or use Dev Server locally)"

must_haves:
  truths:
    - "Song generation jobs are processed asynchronously via Inngest step functions, not fire-and-forget"
    - "Failed generation retries automatically up to 4 times (5 total) with exponential backoff"
    - "After all retries exhausted, failure data is written to failed_jobs table as dead-letter queue entry"
    - "Order status updates accurately through lifecycle: paid -> generating -> completed/failed"
    - "Each song variant's generation_status is tracked independently (pending -> generating -> complete/failed)"
    - "Duplicate Stripe webhooks do not create duplicate orders or trigger duplicate generation jobs"
    - "Stripe webhook responds within seconds (does not wait for generation to complete)"
  artifacts:
    - path: "src/lib/inngest/client.ts"
      provides: "Inngest client instance configured for SongSwipe"
      exports: ["inngest"]
    - path: "src/lib/inngest/functions/generate-song.ts"
      provides: "Durable song generation function with step.run() and onFailure DLQ handler"
      exports: ["generateSongFunction"]
    - path: "src/app/api/inngest/route.ts"
      provides: "Inngest webhook endpoint serving all registered functions"
      exports: ["GET", "POST", "PUT"]
    - path: "src/app/api/webhook/route.ts"
      provides: "Refactored Stripe webhook that triggers Inngest event instead of fire-and-forget"
      contains: "inngest.send"
  key_links:
    - from: "src/app/api/webhook/route.ts"
      to: "src/lib/inngest/client.ts"
      via: "inngest.send() triggers async job"
      pattern: "inngest\\.send.*song/generation\\.requested"
    - from: "src/lib/inngest/functions/generate-song.ts"
      to: "src/lib/elevenlabs.ts"
      via: "calls generateSong() inside step.run()"
      pattern: "step\\.run.*generateSong"
    - from: "src/lib/inngest/functions/generate-song.ts"
      to: "src/lib/supabase.ts"
      via: "writes to song_variants and orders tables via service role client"
      pattern: "createServerSupabaseClient.*song_variants"
    - from: "src/app/api/inngest/route.ts"
      to: "src/lib/inngest/functions/generate-song.ts"
      via: "serves function via Inngest SDK"
      pattern: "serve.*functions.*generateSong"
---

<objective>
Install Inngest and build the async song generation pipeline that replaces the existing fire-and-forget pattern. The webhook triggers an Inngest event, the generation function uses step functions for durable execution with retry, and exhausted failures write to the dead-letter queue.

Purpose: This eliminates the critical bug where users are charged but get no song if generation fails. Every failure is retried automatically and ultimately captured for monitoring. Generation status is tracked per-variant for accurate user-facing progress.

Output: Working Inngest integration with generate-song function, refactored webhook, and DLQ handler. The generation function generates 3 variants per order (the core SongSwipe model).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md

@src/lib/elevenlabs.ts
@src/lib/supabase.ts
@src/app/api/webhook/route.ts
@src/types/database.ts
@package.json
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Inngest and create client + API route</name>
  <files>
    package.json
    src/lib/inngest/client.ts
    src/app/api/inngest/route.ts
    .env.example
  </files>
  <action>
**Step 1: Install Inngest**
```bash
npm install inngest
```

**Step 2: Create Inngest client** at `src/lib/inngest/client.ts`:

```typescript
import { Inngest } from 'inngest';

export const inngest = new Inngest({
  id: 'songswipe',
  name: 'SongSwipe',
});
```

Keep it minimal. The client ID 'songswipe' is used to identify this app in the Inngest dashboard. No event schemas needed at this stage -- TypeScript generics on the function definition handle type safety.

**Step 3: Create Inngest API route** at `src/app/api/inngest/route.ts`:

```typescript
import { serve } from 'inngest/next';
import { inngest } from '@/lib/inngest/client';
import { generateSongFunction } from '@/lib/inngest/functions/generate-song';

export const { GET, POST, PUT } = serve({
  client: inngest,
  functions: [generateSongFunction],
});
```

This registers all Inngest functions and exposes the webhook endpoint that Inngest calls to execute them. The GET handler serves the Inngest dashboard introspection, POST handles function execution, PUT handles registration.

**Step 4: Update .env.example** to add Inngest variables:

Add these lines after the Eleven Labs section:
```
# Inngest Job Queue
INNGEST_EVENT_KEY=your-inngest-event-key
INNGEST_SIGNING_KEY=your-inngest-signing-key
```

Note: Inngest Dev Server (for local development) works without these keys. They are only required in production. The Inngest SDK reads these from environment variables automatically (no code needed to pass them).
  </action>
  <verify>
- `npm ls inngest` shows inngest is installed
- `npx tsc --noEmit` passes (may show errors from Task 2 function import -- that's OK, verify after Task 2)
- `src/lib/inngest/client.ts` exists and exports `inngest`
- `src/app/api/inngest/route.ts` exists and exports GET, POST, PUT
- `.env.example` contains INNGEST_EVENT_KEY and INNGEST_SIGNING_KEY
  </verify>
  <done>
Inngest npm package installed, client configured at src/lib/inngest/client.ts, API route at src/app/api/inngest/route.ts serves the generate-song function, .env.example updated with Inngest variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build generate-song Inngest function with step functions, 3-variant generation, and DLQ handler</name>
  <files>src/lib/inngest/functions/generate-song.ts</files>
  <action>
Create `src/lib/inngest/functions/generate-song.ts` with a durable step-function-based song generation flow. This is the core of Phase 1.

The function must:

1. **Listen for event** `'song/generation.requested'` with data shape `{ orderId: string, userId: string, customizationId: string }`

2. **Configure retries**: `retries: 4` (5 total attempts with exponential backoff, Inngest default backoff is fine)

3. **Configure onFailure handler** that writes to `failed_jobs` table after all retries exhausted

4. **Use step.run()** for each discrete operation to get durable execution (completed steps are skipped on retry):

   **Step 1: 'fetch-customization'**
   - Create server Supabase client (service role) via `createServerSupabaseClient()`
   - Fetch customization by ID from `customizations` table
   - Throw if not found (will retry)
   - Return the customization data

   **Step 2: 'update-order-generating'**
   - Update orders table: set `status = 'generating'` where `id = orderId`

   **Step 3: 'create-variant-records'**
   - Insert 3 song_variant records into `song_variants` table with:
     - order_id, user_id from event data
     - variant_number: 1, 2, 3
     - storage_path: placeholder `'{orderId}/variant-{n}.mp3'` (will be updated after upload)
     - generation_status: 'pending'
     - share_token: auto-generated by database default (gen_random_uuid())
   - Use `INSERT ... ON CONFLICT (order_id, variant_number) DO NOTHING` to handle idempotent retries
   - Return the inserted variant records (need their IDs)

   **Step 4: 'generate-and-upload-variants'**
   - Loop through 3 variants:
     - Update variant status to 'generating' in song_variants table
     - Call `generateSong()` from `@/lib/elevenlabs` with the customization data (mapped to Customization type)
     - Upload audio buffer to Supabase Storage at path `{userId}/{orderId}/variant-{n}.mp3`
     - Update song_variant record: set storage_path, generation_status = 'complete', completed_at = NOW()
   - If a single variant fails, catch the error, set that variant's status to 'failed', and continue with remaining variants (do NOT throw -- partial success is better than total failure)
   - After all 3 attempts, check: if ALL variants failed, throw an error to trigger retry of the whole step

   IMPORTANT: Use `NonRetriableError` from 'inngest' for 400 errors from Eleven Labs (bad input that won't succeed on retry). Use `RetryAfterError` for 429 rate limits (respect Retry-After header).

   **Step 5: 'finalize-order'**
   - Check how many variants completed successfully
   - If at least 1 variant completed: update order status to 'completed'
   - If 0 variants completed: update order status to 'failed'

5. **onFailure handler** (runs after ALL retries exhausted):
   - Write to `failed_jobs` table:
     - job_type: 'song_generation'
     - event_data: the full event.data object (JSONB)
     - error_message: error.message
     - error_stack: error.stack (if available)
     - retry_count: 4 (the configured retry count)
   - Update order status to 'failed'
   - Log structured error: `console.error('Song generation exhausted retries:', { orderId, error: error.message })`

**Mapping customization DB row to Customization type:**
The customization table uses snake_case (recipient_name, your_name, song_length, special_memories, things_to_avoid) but the `generateSong()` function from elevenlabs.ts expects camelCase Customization type. Map explicitly:
```typescript
{
  recipientName: customization.recipient_name,
  yourName: customization.your_name,
  occasion: customization.occasion,
  songLength: customization.song_length.toString(),
  mood: customization.mood,
  genre: customization.genre,
  specialMemories: customization.special_memories || undefined,
  thingsToAvoid: customization.things_to_avoid || undefined,
}
```

Export the function as `generateSongFunction` (named export, not default export -- matching the import in the API route).

**Code conventions to follow:**
- Import with `@/` path alias for internal modules
- Use `console.error('Context:', { structuredData })` pattern for logging
- camelCase for variables, PascalCase for types
- Single quotes for strings
- 2-space indentation
  </action>
  <verify>
- `npx tsc --noEmit` passes
- File exports `generateSongFunction`
- Function has `retries: 4` in config
- Function has `onFailure` handler that writes to `failed_jobs`
- Function uses `step.run()` for each discrete operation
- Function imports `NonRetriableError` and `RetryAfterError` from 'inngest'
- Function imports `generateSong` from '@/lib/elevenlabs'
- Function imports `createServerSupabaseClient` from '@/lib/supabase'
  </verify>
  <done>
generate-song.ts exports generateSongFunction with 5 step.run() operations (fetch customization, update order status, create variant records, generate and upload 3 variants, finalize order), onFailure DLQ handler writing to failed_jobs table, NonRetriableError for 400s, RetryAfterError for 429s, and proper customization field mapping from snake_case to camelCase.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor Stripe webhook to trigger Inngest event instead of fire-and-forget</name>
  <files>src/app/api/webhook/route.ts</files>
  <action>
Refactor `src/app/api/webhook/route.ts` to:

1. **Add Inngest import** at top:
   ```typescript
   import { inngest } from '@/lib/inngest/client';
   ```

2. **Add idempotency check** before creating order: Query `orders` table for existing order with matching `stripe_session_id`. If found, skip order creation and job trigger (handles Stripe webhook retries):
   ```typescript
   const { data: existingOrder } = await supabase
     .from('orders')
     .select('id')
     .eq('stripe_session_id', session.id)
     .maybeSingle();

   if (existingOrder) {
     console.log('Duplicate webhook, order already exists:', existingOrder.id);
     break;
   }
   ```

3. **Replace fire-and-forget call** with Inngest event send. Remove the old `generateAndStoreSong()` call (line 63) and replace with:
   ```typescript
   await inngest.send({
     name: 'song/generation.requested',
     data: {
       orderId: order.id,
       userId: userId,
       customizationId: customizationId,
     },
   });
   ```

4. **Delete the `generateAndStoreSong` function** entirely (lines 88-164). This function is replaced by the Inngest generate-song function. Remove the entire function definition.

5. **Remove the `generateSong` import** from elevenlabs (line 5) since the webhook no longer calls it directly. The Inngest function handles that.

6. **Keep everything else the same**: Stripe signature verification, session metadata extraction, order creation, payment_intent.payment_failed handling, error responses.

The webhook must return 200 quickly (within a few seconds). The `inngest.send()` call is fast -- it just enqueues the event. Actual generation happens asynchronously in the Inngest function.

**What the refactored webhook does:**
1. Verify Stripe signature (existing)
2. Check for duplicate webhook via stripe_session_id (NEW)
3. Create order record with status 'paid' (existing)
4. Send Inngest event to trigger async generation (NEW, replaces fire-and-forget)
5. Return 200 immediately (existing)
  </action>
  <verify>
- `npx tsc --noEmit` passes
- File imports `inngest` from '@/lib/inngest/client'
- File does NOT import `generateSong` from '@/lib/elevenlabs'
- File does NOT contain `generateAndStoreSong` function
- File contains `inngest.send({ name: 'song/generation.requested'`
- File contains idempotency check for `stripe_session_id`
- `npm run build` succeeds (full Next.js build)
  </verify>
  <done>
Webhook route triggers Inngest event instead of fire-and-forget, includes idempotency check for duplicate Stripe webhooks, generateAndStoreSong function removed, build passes. Webhook responds within seconds regardless of generation time.
  </done>
</task>

</tasks>

<verification>
1. `npm install` succeeds, `npm ls inngest` shows inngest installed
2. `npx tsc --noEmit` passes with no errors
3. `npm run build` succeeds (full Next.js production build)
4. src/lib/inngest/client.ts exports inngest client with id 'songswipe'
5. src/lib/inngest/functions/generate-song.ts exports generateSongFunction with retries: 4 and onFailure handler
6. src/app/api/inngest/route.ts exports GET, POST, PUT serving the generate-song function
7. src/app/api/webhook/route.ts sends Inngest event, has idempotency check, does NOT contain generateAndStoreSong
8. .env.example contains INNGEST_EVENT_KEY and INNGEST_SIGNING_KEY
9. No references to fire-and-forget generateAndStoreSong remain in codebase
</verification>

<success_criteria>
- Inngest SDK installed and configured with TypeScript types compiling cleanly
- Generate-song function uses step.run() for durable execution with automatic retry (4 retries = 5 total attempts)
- onFailure handler writes to failed_jobs table (dead-letter queue) after retry exhaustion
- Stripe webhook triggers Inngest event, responds quickly, handles duplicate webhooks
- Old fire-and-forget generateAndStoreSong function completely removed
- Generation produces 3 variants per order with per-variant status tracking
- `npm run build` passes
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-02-SUMMARY.md`
</output>
