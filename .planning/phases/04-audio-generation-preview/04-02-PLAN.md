---
phase: 04-audio-generation-preview
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - src/lib/providers.tsx
  - src/app/layout.tsx
  - src/lib/hooks/useGenerationStatus.ts
  - src/lib/hooks/useAudioPreview.ts
autonomous: true

must_haves:
  truths:
    - "React Query is installed and configured as a client-side provider"
    - "useGenerationStatus hook polls /api/orders/[id]/status every 3 seconds during generation and stops when complete/failed"
    - "useAudioPreview hook fetches audio blob from /api/orders/[id]/variants/[variantId]/preview and returns a revocable object URL"
    - "Object URLs are cleaned up on unmount to prevent memory leaks"
  artifacts:
    - path: "src/lib/providers.tsx"
      provides: "QueryClientProvider wrapper for app layout"
      contains: "QueryClientProvider"
    - path: "src/lib/hooks/useGenerationStatus.ts"
      provides: "React Query hook for polling generation status"
      exports: ["useGenerationStatus"]
    - path: "src/lib/hooks/useAudioPreview.ts"
      provides: "Hook for fetching audio preview as blob URL"
      exports: ["useAudioPreview"]
  key_links:
    - from: "src/lib/hooks/useGenerationStatus.ts"
      to: "/api/orders/[id]/status"
      via: "fetch in React Query queryFn"
      pattern: "fetch.*api/orders.*status"
    - from: "src/lib/hooks/useAudioPreview.ts"
      to: "/api/orders/[id]/variants/[variantId]/preview"
      via: "fetch with blob conversion"
      pattern: "fetch.*preview.*blob"
    - from: "src/lib/providers.tsx"
      to: "src/app/layout.tsx"
      via: "Provider wrapping children"
      pattern: "Providers.*children"
---

<objective>
Install React Query, create the app-level provider, and build the two client-side hooks that power the generation page: useGenerationStatus for polling and useAudioPreview for protected audio playback.

Purpose: These hooks encapsulate the client-side data fetching logic that the generation page UI (Plan 03) will consume. Separating hooks from UI allows parallel development with the API endpoints (Plan 01) and keeps the generation page components focused on presentation.

Output: React Query installed, provider configured, two typed hooks ready for consumption by Plan 03.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-audio-generation-preview/04-RESEARCH.md
@src/app/layout.tsx
@src/types/database.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install React Query and create app-level provider</name>
  <files>
    package.json
    src/lib/providers.tsx
    src/app/layout.tsx
  </files>
  <action>
1. Install React Query: `npm install @tanstack/react-query`

2. Create `src/lib/providers.tsx`:
```tsx
'use client'

import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useState } from 'react'

export function Providers({ children }: { children: React.ReactNode }) {
  // Create QueryClient in useState to avoid sharing between requests in SSR
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: 1,
      },
    },
  }))

  return (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  )
}
```

3. Update `src/app/layout.tsx`:
- Import `Providers` from `@/lib/providers`
- Wrap `{children}` (and Header) inside `<Providers>` in the body
- Keep the existing `<html lang="en">` and `<body>` structure
- The layout is a server component but Providers is a client component (this pattern is standard Next.js)

Result:
```tsx
<body className="antialiased">
  <Providers>
    <Header />
    {children}
  </Providers>
</body>
```
  </action>
  <verify>
`npm ls @tanstack/react-query` shows installed version.
`ls src/lib/providers.tsx` confirms file exists.
Check layout.tsx includes Providers wrapper.
  </verify>
  <done>
React Query installed and QueryClientProvider wraps the entire app via layout.tsx. QueryClient created with sensible defaults (5s staleTime, 1 retry).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useGenerationStatus and useAudioPreview hooks</name>
  <files>
    src/lib/hooks/useGenerationStatus.ts
    src/lib/hooks/useAudioPreview.ts
  </files>
  <action>
1. Create `src/lib/hooks/useGenerationStatus.ts`:

Define TypeScript interfaces matching the API response from Plan 01:
```typescript
interface VariantStatus {
  id: string
  variant_number: number
  generation_status: 'pending' | 'generating' | 'complete' | 'failed'
  storage_path: string | null
  completed_at: string | null
}

interface GenerationStatusResponse {
  order_id: string
  order_status: 'paid' | 'generating' | 'completed' | 'failed'
  variants: VariantStatus[]
}
```

Export `useGenerationStatus(orderId: string)`:
- Use `useQuery` from `@tanstack/react-query`
- queryKey: `['generation-status', orderId]`
- queryFn: fetch `/api/orders/${orderId}/status`, throw on non-ok response
- refetchInterval: Use callback function. Return `3000` (3 seconds) when `order_status` is 'paid' or 'generating'. Return `false` when 'completed' or 'failed' (stop polling).
- refetchOnWindowFocus: false (don't re-poll when user switches back to tab)
- enabled: `!!orderId` (don't poll if no orderId)

Also export derived convenience values:
```typescript
const isGenerating = data?.order_status === 'generating' || data?.order_status === 'paid'
const isComplete = data?.order_status === 'completed'
const isFailed = data?.order_status === 'failed'
const completedVariants = data?.variants.filter(v => v.generation_status === 'complete') || []
const completedCount = completedVariants.length
const totalVariants = data?.variants.length || 0
```

Return: `{ data, isLoading, error, isGenerating, isComplete, isFailed, completedVariants, completedCount, totalVariants }`

2. Create `src/lib/hooks/useAudioPreview.ts`:

Export `useAudioPreview(orderId: string, variantId: string | null)`:
- Use `useState` for `audioUrl`, `loading`, `error`
- Use `useRef<HTMLAudioElement>(null)` for audioRef
- Use `useEffect` that triggers when orderId or variantId changes:
  - If variantId is null, skip (don't fetch)
  - Fetch `/api/orders/${orderId}/variants/${variantId}/preview`
  - If response not ok, set error
  - Convert response to blob: `response.blob()`
  - Create object URL: `URL.createObjectURL(blob)`
  - Set audioUrl state
  - Cleanup function: call `URL.revokeObjectURL(objectUrl)` when effect re-runs or unmounts (prevents memory leaks per research pitfall 3)
- Return: `{ audioUrl, loading, error, audioRef }`

**Memory leak prevention is critical:** The cleanup function MUST revoke the previous object URL before creating a new one when variantId changes.

Export both hooks as named exports from their respective files (no default exports, matching codebase convention).
  </action>
  <verify>
`ls src/lib/hooks/useGenerationStatus.ts src/lib/hooks/useAudioPreview.ts` confirms both files exist.
TypeScript compilation: `npx tsc --noEmit` passes for new hook files.
  </verify>
  <done>
useGenerationStatus polls every 3s during generation and stops on completion, with typed response and derived convenience values. useAudioPreview fetches audio as blob URL with proper cleanup to prevent memory leaks. Both hooks ready for consumption by generation page UI.
  </done>
</task>

</tasks>

<verification>
1. `@tanstack/react-query` in package.json dependencies
2. Providers component wraps app in layout.tsx
3. useGenerationStatus hook polls with 3s interval and stops on complete/failed
4. useAudioPreview hook returns blob URL and revokes on cleanup
5. TypeScript compilation passes
6. No import errors in hook files
</verification>

<success_criteria>
React Query installed, app-level provider configured, and two typed hooks (useGenerationStatus, useAudioPreview) created with proper polling logic, blob URL management, and memory leak prevention. Ready for Plan 03 UI integration.
</success_criteria>

<output>
After completion, create `.planning/phases/04-audio-generation-preview/04-02-SUMMARY.md`
</output>
